# Complete Database Setup for FutureBank

## Overview
This guide provides the complete database setup for the FutureBank application, including proper foreign key relationships, automatic profile creation, and username validation.

## Database Schema

### 1. Profiles Table
```sql
-- Create profiles table
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  avatar_url TEXT,
  time_balance DECIMAL(10,2) DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add username validation constraint
ALTER TABLE public.profiles 
ADD CONSTRAINT username_format 
CHECK (username ~ '^[a-zA-Z0-9_]{3,20}$');

-- Enable RLS (Row Level Security)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile" ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

-- Allow public read access for usernames (for marketplace functionality)
CREATE POLICY "Public can view usernames" ON public.profiles
  FOR SELECT USING (true);
```

### 2. Offers Table
```sql
-- Create offers table
CREATE TABLE public.offers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  title TEXT,
  description TEXT,
  category TEXT,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);

-- Enable RLS
ALTER TABLE public.offers ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view all offers" ON public.offers
  FOR SELECT USING (true);

CREATE POLICY "Users can insert their own offers" ON public.offers
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own offers" ON public.offers
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own offers" ON public.offers
  FOR DELETE USING (auth.uid() = user_id);
```

### 3. Wants Table (with criteria)
```sql
-- Create wants table
CREATE TABLE public.wants (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  title TEXT,
  description TEXT,
  category TEXT,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  criteria TEXT[] DEFAULT '{}'::text[]
);

-- Add comment for criteria column
COMMENT ON COLUMN public.wants.criteria IS 'Array of criteria strings for the want (e.g., ["public_place", "accessible", "daytime_only"])';

-- Enable RLS
ALTER TABLE public.wants ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view all wants" ON public.wants
  FOR SELECT USING (true);

CREATE POLICY "Users can insert their own wants" ON public.wants
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own wants" ON public.wants
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own wants" ON public.wants
  FOR DELETE USING (auth.uid() = user_id);
```

## Automatic Profile Creation (Recommended)

### Option 1: Database Trigger (Recommended)
```sql
-- Create function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, avatar_url, time_balance)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)),
    NEW.raw_user_meta_data->>'avatar_url',
    0
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to automatically create profile on user signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

### Option 2: Application-Level Profile Creation (Current Implementation)
The current implementation in the modals will automatically create profiles when users try to create offers or wants. This is handled by the `ensureProfileExists()` function in both `AddOfferModal` and `AddWantModal`.

## Username Validation

### Database-Level Validation
- **Uniqueness**: Username must be unique across all users
- **Format**: 3-20 characters, letters, numbers, and underscores only
- **Required**: Username cannot be null

### Application-Level Validation
The ProfileSettingsModal includes client-side validation:
- Length check (3-20 characters)
- Format validation (letters, numbers, underscores only)
- Uniqueness check against existing usernames

## Migration for Existing Users

If you have existing users without profiles, run this to create profiles for them:

```sql
-- Create profiles for existing users who don't have them
INSERT INTO public.profiles (id, username, avatar_url, time_balance)
SELECT 
  au.id,
  COALESCE(au.raw_user_meta_data->>'username', split_part(au.email, '@', 1)),
  au.raw_user_meta_data->>'avatar_url',
  0
FROM auth.users au
LEFT JOIN public.profiles p ON au.id = p.id
WHERE p.id IS NULL;

-- Handle duplicate usernames by adding numbers
WITH duplicates AS (
  SELECT id, username,
         ROW_NUMBER() OVER (PARTITION BY username ORDER BY created_at) as rn
  FROM public.profiles
)
UPDATE public.profiles 
SET username = p.username || '_' || (p.rn - 1)
FROM duplicates p
WHERE public.profiles.id = p.id AND p.rn > 1;
```

## Testing the Setup

### Test Profile Creation
```sql
-- Check if profiles exist for all users
SELECT 
  au.id,
  au.email,
  p.username,
  p.time_balance
FROM auth.users au
LEFT JOIN public.profiles p ON au.id = p.id;
```

### Test Username Validation
```sql
-- Test valid username
INSERT INTO public.profiles (id, username, avatar_url, time_balance) 
VALUES ('test-uuid', 'valid_username123', null, 0);

-- Test invalid username (should fail)
INSERT INTO public.profiles (id, username, avatar_url, time_balance) 
VALUES ('test-uuid-2', 'invalid-username!', null, 0);
```

### Test Want Creation
```sql
-- Test inserting a want (replace 'user-uuid' with actual user ID)
INSERT INTO public.wants (title, description, category, user_id, criteria) 
VALUES (
  'Help with Bike Repair', 
  'My bike chain keeps slipping and I need help fixing it.', 
  'Repair', 
  'user-uuid-here', 
  ARRAY['public_place', 'daytime_only', 'accessible']
);
```

## Troubleshooting

### Foreign Key Constraint Error
If you get the error "insert or update on table 'wants' violates foreign key constraint 'wants_user_id_fkey'", it means:

1. The user doesn't have a profile record
2. The `user_id` doesn't exist in the `profiles` table

**Solution**: The updated modals will automatically create a profile if one doesn't exist.

### Username Uniqueness Error
If you get a username uniqueness error:

1. The username is already taken
2. The application will show an error message
3. Users can choose a different username

### Permission Errors
If you get permission errors, make sure:

1. RLS policies are properly set up
2. The user is authenticated
3. The user has the correct permissions

## Security Notes

- All tables have Row Level Security (RLS) enabled
- Users can only modify their own data
- Public read access for offers and wants (for marketplace functionality)
- Usernames are publicly readable but only editable by the owner
- Profile creation is handled securely through triggers or application logic

## Next Steps

1. Run the database schema creation scripts
2. Set up the automatic profile creation trigger (recommended)
3. Test the application with new user signups
4. Verify that offers and wants can be created successfully
5. Test username validation and uniqueness 